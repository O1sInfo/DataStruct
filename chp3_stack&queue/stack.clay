栈：是限定仅在表尾进行插入或删除操作的线性表。

栈又称为后进先出（LIFO）的线性表

基本操作：
	InitStack(&S)
	DestoryStack(&S)
	ClearStack(&S)
	StackEmpty(S)
	StackEmpty(S)
	GetTop(S, &e)
	Push(&S, e)
	Pop(&S, e)
	StackTraverse(S, visit())

栈的表示和实现：
两种存储方式：顺序栈，链栈

顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放栈底到栈顶的元素，
同时附设指针top指示栈顶元素在顺序栈中的元素

一般来说，在初始化设空栈时不应限定栈的最大容量。一个较合理的做法是：先为栈分配一个基本容量，然后当栈的
空间不够用时在扩大。

任何一个表达式都是由操作数、运算符、界限符组成的。

算法：算符优先法
我们把运算符和界限符统称算符。
为实现算符优先算法，可以使用两个工作栈。一个称为OPTR,用以寄存运算符；另一个是OPND,用以寄存操作数和运算结果。
算法的基本思想是:
	(1)首先置操作数栈为空栈，表达式起始符‘#’为运算符栈的栈底元素
	(2)依次读入表达式中的每个字符，若是操作数则进入OPND栈，若是运算符则和OPTR栈的栈顶运算符比较优先权后做相应的
	操作，直至整个表达式求值完毕(即OPTR栈的栈顶元素和当前读入的字符均为'#')
	

栈还有一个重要应用是在程序设计语言中实现递归。
例如如下递归函数：
阶乘函数	Fact(n) = n.Fact(n-1) , Fact(0) = 1
2阶Fibonacci数列	Fib(0)=0, Fib(1)=1; Fib(n) = Fib(n-1)+Fib(n-2)
Ackerman函数	Ack(0,n) = n+1;	Ack(m, 0) = Ack(m-1, 1);	Ack(m,n) = Ack(m-1, Ack(m, n-1))

n阶Hanoi塔问题：